<HTML>
<HEAD>
<TITLE>SortedSeek.pm</TITLE>
<LINK REL="stylesheet" HREF="../html/docs.css" TYPE="text/css">
<LINK REV="made" HREF="mailto:">
</HEAD>

<BODY>
<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH=100%>
<TR><TD CLASS=block VALIGN=MIDDLE WIDTH=100% BGCOLOR="#cccccc">
<FONT SIZE=+1><STRONG><P CLASS=block>&nbsp;SortedSeek.pm</P></STRONG></FONT>
</TD></TR>
</TABLE>

<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

    <UL>

        <LI><A HREF="#name">NAME</A></LI>
        <LI><A HREF="#synopsis">SYNOPSIS</A></LI>
        <LI><A HREF="#description">DESCRIPTION</A></LI>
        <UL>

            <LI><A HREF="#abstract">ABSTRACT</A></LI>
            <LI><A HREF="#the two basic methods  numeric() and alphabetic()">The two basic methods - <CODE>numeric()</CODE> and <CODE>alphabetic()</CODE></A></LI>
            <LI><A HREF="#return values with search success and failure">Return values with search success and failure</A></LI>
            <LI><A HREF="#adding line munging to make the basic methods more useful">Adding line munging to make the basic methods more useful</A></LI>
            <LI><A HREF="#find_time()"><CODE>find_time()</CODE></A></LI>
            <LI><A HREF="#getting lines from the middle of a file  get_between()">Getting lines from the middle of a file  - <CODE>get_between()</CODE></A></LI>
            <LI><A HREF="#getting the lines from the beginning of a file  get_between()">Getting the lines from the beginning of a file - <CODE>get_between()</CODE></A></LI>
            <LI><A HREF="#getting lines from the end of a file  get_between()">Getting lines from the end of a file - <CODE>get_between()</CODE></A></LI>
            <LI><A HREF="#getting lines from the end of a file  get_last()">Getting lines from the end of a file - <CODE>get_last()</CODE></A></LI>
        </UL>

        <LI><A HREF="#export">EXPORT</A></LI>
        <LI><A HREF="#options">OPTIONS</A></LI>
        <UL>

            <LI><A HREF="#file::seek::error()">File::Seek::error()</A></LI>
            <LI><A HREF="#file::seek::was_exact()">File::Seek::was_exact()</A></LI>
            <LI><A HREF="#file::seek::set_cuddle() file::seek::set_no_cuddle()">File::Seek::set_cuddle()  File::Seek::set_no_cuddle()</A></LI>
            <LI><A HREF="#file::seek::set_descending() file::seek::set_ascending()">File::Seek::set_descending() File::Seek::set_ascending()</A></LI>
            <LI><A HREF="#file::seek::set_max_tries($max)">File::Seek::set_max_tries($max)</A></LI>
            <LI><A HREF="#file::seek::set_line_length($integer)">File::Seek::set_line_length($integer)</A></LI>
            <LI><A HREF="#file::seek::set_silent() file::seek::set_verbose()">File::Seek::set_silent()  File::Seek::set_verbose()</A></LI>
            <LI><A HREF="#file::seek::set_debug() file::seek::no_debug()">File::Seek::set_debug()  File::Seek::no_debug()</A></LI>
        </UL>

        <LI><A HREF="#speed">SPEED</A></LI>
        <LI><A HREF="#bugs">BUGS</A></LI>
        <LI><A HREF="#author">AUTHOR</A></LI>
        <LI><A HREF="#see also">SEE ALSO</A></LI>
    </UL>

</UL>
<!-- INDEX END -->

<HR>
<P>
<H2><A NAME="name">NAME</A></H2>
<P>File::SortedSeek -  A Perl module providing fast access to large files</P>
<P>
<H2><A NAME="synopsis">SYNOPSIS</A></H2>
<PRE>
  use File::Seek ':all';
  open BIG, $file or die $!;</PRE>
<PRE>
  # find a number or the first number greater in a file (ascending order)
  $tell = numeric( *BIG, $number );
  # read a line in from where we matched in the file
  $line = &lt;BIG&gt;;
  print &quot;Found exact match as $line&quot; if File::Seek:was_exact();</PRE>
<PRE>
  # find a string or the first string greater in a file (alphabetical order)
  $tell = alphabetic( *BIG, $string );
  $line = &lt;BIG&gt;;</PRE>
<PRE>
  # find a date in a logfile supplying a scalar localtime type string
  $tell = find_time( *BIG, &quot;Thu Aug 23 22:59:16 2001&quot; );
  # or supplying GMT epoch time
  $tell = find_time( *BIG, 998571554 );
  # get all the lines after our date
  @lines = &lt;BIG&gt;;</PRE>
<PRE>
  # get the lines between two logfile dates
  $begin  = find_time( *LOG, $start );
  $end    = find_time( *LOG, $finish );
  # get lines as an array
  @lines = get_between( *LOG, $begin, $end );
  # get lines as an array reference
  $lines = get_between( *LOG, $begin, $end );</PRE>
<PRE>
  # use you own sub to munge the file line data before comparison
  $tell = numeric( *BIG, $number, \&amp;epoch );
  $tell = alphabetic( *BIG, $string, \&amp;munge_line );</PRE>
<PRE>
  # use methods on files in reverse alphabetic or descending numerical order
  File::Seek::set_descending();</PRE>
<PRE>
  # for inexact matches set FH so first value read is before and second after
  File::Seek::set_cuddle();</PRE>
<PRE>
  # get last $n lines of any file as an array
  @lines = get_last( *BIG, $n )
  # or an array reference
  $lines = get_last( *BIG, $n )
  # change the input record separator from the OS default
  @lines = get_last( *BIG, $n, $rec_sep )</PRE>
<P>
<H2><A NAME="description">DESCRIPTION</A></H2>
<P>File::OrderedSeek provides fast access to data from large files. Three 
methods <CODE>numeric()</CODE> <CODE>alphabetic()</CODE> and <CODE>find_time()</CODE> depend on the file data 
being sorted in some way. Logfiles are a typical example of big files that 
are sorted (by date stamp). The <CODE>get_between()</CODE> method can be used to get 
a chunk of lines efficiently from anywhere in the file. The required <CODE>postion(s)</CODE> 
for the <CODE>get_between()</CODE> method are supplied by the previous methods. The 
<CODE>get_last()</CODE> method will efficiently get the last N lines of any file, sorted 
or not.</P>
<P>With sorted data a linear search is not required. Here is a typical linear 
search</P>
<PRE>
    while (&lt;FILE&gt;) {
        next unless /$some_cond/
        # found cond, do stuff
    }</PRE>
<P>Remember that old game where you try to guess a number between lets say 0 
and say 128? Let's choose 101 and now try to guess it.</P>
<P>Using a linear search is the same as going 1 higher 2 higher 3 higher ... 
100 higher 101 correct! Consider the geometric approach: 64 higher 96 higher 
112 lower 104 lower 100 higher 102 lower - ta da must be 101! This is the 
halving the difference search method and can be applied to any data set where 
we can logically say higher or lower. In other words any sorted data set can 
be searched like this. It is a far more efficient method - see the SPEED 
section for a quick analysis.</P>
<P>
<H3><A NAME="abstract">ABSTRACT</A></H3>
<P>Fiel::OrderedSeek provides fast access to data from large files. Three 
methods <CODE>numeric()</CODE> <CODE>alphabetic()</CODE> and <CODE>find_time()</CODE> depend on the file data 
being sorted in some way. Logfiles are a typical example of big files that 
are sorted (by date stamp). The <CODE>get_between()</CODE> method can be used to get 
a chunk of lines efficiently from anywhere in the file. The required <CODE>postion(s)</CODE> 
for the <CODE>get_between()</CODE> method are supplied by the previous methods. The 
<CODE>get_last()</CODE> method will efficiently get the last N lines of any file, sorted 
or not.</P>
<P>
<H3><A NAME="the two basic methods  numeric() and alphabetic()">The two basic methods - <CODE>numeric()</CODE> and <CODE>alphabetic()</CODE></A></H3>
<P>There are two basic methods - <CODE>numeric()</CODE> to do numeric searches and 
<CODE>alphabetic()</CODE> that does alphabetic searches.</P>
<P>You call the functions like this:</P>
<PRE>
    $tell = numeric( *BIG, $find );
    $tell = alphabetic( *BIG, $find );</PRE>
<P>These methods take two required arguments. *BIG is a FILEHANDE to read from. 
$find is the item you wish to find. $find must be appropriate to the function 
as the numeric method will make numeric comparisons ( == &lt; &gt; ). Similarly the 
alphabetic method makes string comparisons ( eq lt gt ). You will get strange 
results if you use the wrong method just as you do if you say use == when 
you actually meant eq</P>
<P>
<H3><A NAME="return values with search success and failure">Return values with search success and failure</A></H3>
<P>The return value from the <CODE>numeric()</CODE> and <CODE>alphabetic()</CODE> methods depend on the 
result of the search. If the search fails the return value is undefined. 
A search can succeed in two ways. If an exact match is found then the 
current file position pointer is set to the beginning of the matching line. 
The return value is the corresponding response from tell(). This means that 
the next read from &lt;FILEHANDLE&gt; will return the matching line. 
Subsequent reads return the following lines as expected.</P>
<P>Alternatively a search will succeed if a point in the file can be found such 
that $find is cuddled between two adjacent lines. For example consider 
searching for the number 42 in a file like this:</P>
<PRE>
    ..
    36
    40  &lt;- Before
    44  &lt;- After
    48
    ..</PRE>
<P>The number 42 is not actually there but the search will still succeed as it 
is between 40 and 44. By default the file postion pointer is set to the 
beginning of the line '44' so the next read from &lt;FILEHANDLE&gt; will return 
this line. If the File::Seek::set_cuddle() function is called then the file 
position pointer will be set to the beginning of line '40' so that the 
first two reads from &lt;FILEHANDLE&gt; will cuddle the in-between value in $find.</P>
<P>
<H3><A NAME="adding line munging to make the basic methods more useful">Adding line munging to make the basic methods more useful</A></H3>
<P>Both the numeric and alphabetic subs take an optional third argument. 
This optional argument is a reference to a subroutine to munge the 
file lines so that suitable values are extracted for comparison to $find.</P>
<PRE>
    $tell = numeric( *BIG, $find, \&amp;munge_line );
    $tell = alphabetic( *BIG, $find, \&amp;munge_line );</PRE>
<P>A good example of this is the <CODE>find_time()</CODE> function. This is just an 
implementation of the basic numeric algorithm similar to this.</P>
<PRE>
    $tell = numeric ( *BIG, $epoch_seconds, \&amp;get_epoch_seconds );</PRE>
<PRE>
    sub get_epoch_seconds {
        use Time::Local;
        my $line  = shift;
      return undef unless defined $line;
        my %months = 
            ( Jan =&gt; 0, Feb =&gt; 1, Mar =&gt; 2, Apr =&gt; 3, May =&gt; 4,  Jun =&gt; 5, 
              Jul =&gt; 6, Aug =&gt; 7, Sep =&gt; 8, Oct =&gt; 9, Nov =&gt; 10, Dec =&gt; 12);
        # grab a scalar localtime looking like string from the line
        my ($wday,$mon,$mday,$hours,$min,$sec,$year) = 
            $line =~ m/(\w\w\w)\s+(\w\w\w)\s+(\d{1,2})\s+(\d\d):(\d\d):(\d\d)\s+(\d{4})/;
        unless ($year) {
            $error_msg = &quot;Unable to find time like string in line:\n$line&quot;;
            warn $error_msg unless $silent;
          return undef;
        }   
        $mon = $months{$mon};   # convert to numerical months 0 - 11
      return timegm($sec,$min,$hours,$mday,$mon,$year);
    }</PRE>
<P>As the search is made the test lines are passed to the munging sub. This sub 
needs to return a string or number that we can perform comparison on. In this 
case the sub looks for something that looks like a scalar <CODE>localtime()</CODE> string, 
and assuming this is a date passes it to <CODE>timegm()</CODE> for conversion to 
epoch seconds and returns this number.</P>
<P>You can see further examples of this in the test suite test.pl</P>
<P>
<H3><A NAME="find_time()"><CODE>find_time()</CODE></A></H3>
<P>The <CODE>find_time()</CODE> function is an implementation of the basic numeric method as 
discussed briefly above. You call it like:</P>
<PRE>
    $tell = find_time( *LOG, 'Thu Jan  1 00:42:00 1970' );
    $tell = find_time( *LOG, $epoch_seconds );</PRE>
<P>You may use either a scalar <CODE>localtime()</CODE> like string or epoch seconds. If you 
use epoch seconds it assumes gmtime. If in doubt use the string as although 
it works internally with gmtime the offsets cancel out and the correct result 
is returned.</P>
<P>
<H3><A NAME="getting lines from the middle of a file  get_between()">Getting lines from the middle of a file  - <CODE>get_between()</CODE></A></H3>
<P>Say you have a logfile and you want to get the log between one date and 
another. You can simply use two calls to the <CODE>find_time()</CODE> to get the beginning 
and end positions and then use <CODE>get_between()</CODE> to get the lines.</P>
<PRE>
    # get the lines between two logfile dates
    $begin  = find_time( *LOG, $start );
    $end    = find_time( *LOG, $finish );
    # get lines as an array
    @lines = get_between( *LOG, $begin, $end );
    # get lines as an array reference
    $lines = get_between( *LOG, $begin, $end );</PRE>
<P>The <CODE>get_between()</CODE> method returns an array in list context as above and a 
reference to an array in scalar context.</P>
<P>This function needs to apply binmode so it splits the lines based on a system 
specific default record separator. This is derived as below:</P>
<PRE>
    my $default_rec_sep = ($^O =~ m/win32|vms/i) ? &quot;\015\012&quot; : 
                          ( $^O =~ /mac/i ) ? &quot;\015&quot; : &quot;\012&quot;;</PRE>
<P>You can override this on a per file basis by passing the record separator 
to the <CODE>get_between()</CODE> function.</P>
<PRE>
    @lines = get_between( *LOG, $begin, $end, $rec_sep );</PRE>
<P>Modifying $/ has no effect. Note that *the record separator is not returned* 
in the array. As a result the returned array has effectively had every 
element chomped.</P>
<P>Warning - this method will apply binmode to the FH so line endings 
will possibly not be converted properly if you try to continue to read from 
it. As there is no <CODE>unbinmode()</CODE> close the FH afterwards and reopen it if you 
want to read from it. You can seek FH, 0, $end if say you want to read more 
lines after $end.</P>
<P>
<H3><A NAME="getting the lines from the beginning of a file  get_between()">Getting the lines from the beginning of a file - <CODE>get_between()</CODE></A></H3>
<P>Using the <CODE>get_between()</CODE> method you can efficiently get the lines at the 
beginning of a file. Although you can just read in lines sequentially with 
a while loop this requires that you test each line. If you can find the 
end point using the <CODE>find_time()</CODE> <CODE>numeric()</CODE> or <CODE>alphabetic()</CODE> methods you 
can the just get what you need. For large files many thousands of 
unnecessary tests are avoided saving time. Using the example above 
you simply set $begin to 0</P>
<PRE>
    $begin  = 0;
    $end    = find_time( *LOG, $finish );
    @lines  = get_between( *LOG, $begin, $end );</PRE>
<P>
<H3><A NAME="getting lines from the end of a file  get_between()">Getting lines from the end of a file - <CODE>get_between()</CODE></A></H3>
<P>You can similarly use get between to get all the lines from a specific point 
up to the end of the file. The end is just the size of the file so:</P>
<PRE>
    $begin = find_time( *LOG, $start );
    $end   = -s LOG;
    @lines = get_between( *LOG, $begin, $end );</PRE>
<P>
<H3><A NAME="getting lines from the end of a file  get_last()">Getting lines from the end of a file - <CODE>get_last()</CODE></A></H3>
<P>This method does not depend on the file being sorted to work.
When you use the <CODE>get_last()</CODE> method the module estimates how many bytes at 
the end of the file to read in. To make the estimate the module  multiplies 
the default line length (80 chars) by the number of lines required and then 
doubles it.</P>
<P>If it does not get sufficient lines on its first attempt it re-estimates 
the line length from the actual data read in, re-calculates 
the read, doubles it and then tries again. This algorithm is unlikely to 
take more than 2 reads but if you have unusually long of short lines you may 
get a small speed benefit by using the <CODE>set_line_length()</CODE> method to set the 
average line length. The default is 80 chars per line. Setting the line length 
close to the actual will also avoid reading a excessive quantity of data into 
memory.</P>
<PRE>
    # get last $n lines of any file as an array
    @lines = get_last( *BIG, $n )
    # or an array reference
    $lines = get_last( *BIG, $n )
    # change the input record separator from the default
    @lines = get_last( *BIG, $n, $rec_sep )</PRE>
<P>This function needs to apply binmode so it splits the lines based on a system 
specific default record separator. This is derived as below:</P>
<PRE>
    my $default_rec_sep = ($^O =~ m/win32|vms/i) ? &quot;\015\012&quot; : 
                          ( $^O =~ /mac/i ) ? &quot;\015&quot; : &quot;\012&quot;;</PRE>
<P>You can override this on a per file basis by passing the record separator 
$rec_sep to the <CODE>get_last()</CODE> function as shown. Modifying $/ has no effect.
Note that *the record separator is not returned* in the array. As a 
result the returned array has effectively had every element chomped.</P>
<P>Warning - this method will apply binmode to the FH so line endings 
will possibly not be converted properly if you try to continue to read from 
it. As there is no <CODE>unbinmode()</CODE> close the FH afterwards and reopen it if you 
want to read from it. You can seek FH, 0, $end if say you want to read more 
lines after $end.</P>
<P>
<H2><A NAME="export">EXPORT</A></H2>
<P>Nothing is exported by default. The following 5 methods are available for 
import:</P>
<PRE>
    alphabetic() 
    numeric() 
    find_time()
    get_between()
    get_last()</PRE>
<P>You can import just the method you want with a:</P>
<PRE>
    use File::Seek 'numeric';</PRE>
<P>or all 5  methods using the ':all' tag.</P>
<PRE>
    use File::Seek ':all';</PRE>
<P>
<H2><A NAME="options">OPTIONS</A></H2>
<P>There are some options available via non exported function
calls. You will need to fully specify the name if you want to use these.</P>
<P>
<H3><A NAME="file::seek::error()">File::Seek::error()</A></H3>
<P>If a function returns undefined there has been an error. <CODE>error()</CODE> will 
contain the text of the last error message or a null string if there 
was no error.</P>
<P>
<H3><A NAME="file::seek::was_exact()">File::Seek::was_exact()</A></H3>
<P><CODE>was_exact()</CODE> will return true if an exact match was found. It will be 
false if the match was in between or failed.</P>
<P>
<H3><A NAME="file::seek::set_cuddle() file::seek::set_no_cuddle()">File::Seek::set_cuddle()  File::Seek::set_no_cuddle()</A></H3>
<P><CODE>set_cuddle()</CODE> changes the default line returned for in between matches  as 
discussed above and <CODE>set_no_cuddle()</CODE> restores default behaviour</P>
<P>
<H3><A NAME="file::seek::set_descending() file::seek::set_ascending()">File::Seek::set_descending() File::Seek::set_ascending()</A></H3>
<P>By default ascending numerical order and alphabetical order are assumed. 
This assumption can be reversed by calling <CODE>set_descending()</CODE> and reset 
by calling <CODE>set_ascending()</CODE> We need to know the order to seek within the 
file in the correct direction.</P>
<P>
<H3><A NAME="file::seek::set_max_tries($max)">File::Seek::set_max_tries($max)</A></H3>
<P>This sets the maximum times that the module will try the halve the 
difference search before it decides there is a problem and bails out. 
The default value is 42 which allows files with up to 2**42 or a bit more 
than 10**12 lines to be processed. A seek in a million line file will take a 
mere 20 tries to find the required value.</P>
<P>
<H3><A NAME="file::seek::set_line_length($integer)">File::Seek::set_line_length($integer)</A></H3>
<P>When you use the <CODE>get_last()</CODE> method the module uses its default 
line length to estimate how many bytes at the end of the file to read in. 
You can improve speed slightly and decrease memory usage by setting an 
accurate line length. The default is 80 chars per line. The function will
work fine regardless of what the line length is, this is just an efficiency 
tweak.</P>
<P>
<H3><A NAME="file::seek::set_silent() file::seek::set_verbose()">File::Seek::set_silent()  File::Seek::set_verbose()</A></H3>
<P>You can silence or activate error messages by calling these two subs. The 
default is verbose.</P>
<P>
<H3><A NAME="file::seek::set_debug() file::seek::no_debug()">File::Seek::set_debug()  File::Seek::no_debug()</A></H3>
<P>Sets debug on or off. Default is of course off.</P>
<P>
<H2><A NAME="speed">SPEED</A></H2>
<P>Here is a table that demonstrates the advantage of using the halve the 
difference algorithm.</P>
<PRE>
    Num items   Lin avg  Geom avg  Lin:Geom
            2         1         1         1
            4         2         2         1
            8         4         3         1
           16         8         4         2
           32        16         5         3
           64        32         6         5
          128        64         7         9
          256       128         8        16
          512       256         9        28
         1024       512        10        51
         2048      1024        11        93
         4096      2048        12       170
         8192      4096        13       315
        16384      8192        14       585
        32768     16384        15      1092
        65536     32768        16      2048
       131072     65536        17      3855
       262144    131072        18      7281
       524288    262144        19     13797
      1048576    524288        20     26214</PRE>
<P>Even though there is an overhead involved with this search this is minor 
as the number of tests required is so much less. Speed increases of 100-1000 
of times are typical.</P>
<P>An OO interface slows things down by &gt; 50% so is not used.</P>
<P>
<H2><A NAME="bugs">BUGS</A></H2>
<P>Bound to be some. The binmoding of the FH by <CODE>get_between()</CODE> and <CODE>get_last()</CODE> can 
not be easily avoided.</P>
<P>
<H2><A NAME="author">AUTHOR</A></H2>
<P>(c) Dr James Freeman 2000-01 &lt;<A HREF="mailto:jfreeman@tassie.net.au">jfreeman@tassie.net.au</A>&gt; 
All rights reserved.</P>
<P>This package is free software and is provided ``as is'' without express or 
implied warranty. It may be used, redistributed and/or modified under the terms 
of the Perl Artistic License (see <A HREF="http://www.perl.com/perl/misc/Artistic.html)">http://www.perl.com/perl/misc/Artistic.html)</A></P>
<P>
<H2><A NAME="see also">SEE ALSO</A></H2>
<P>For details about the mystical significance of the number 42 and how it can 
be applied to Life the Universe and everything see The Hitch Hiker's Guide 
to the Galaxy 'trilogy' by the recently departed Douglas Adams.</P>
<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH=100%>
<TR><TD CLASS=block VALIGN=MIDDLE WIDTH=100% BGCOLOR="#cccccc">
<FONT SIZE=+1><STRONG><P CLASS=block>&nbsp;SortedSeek.pm</P></STRONG></FONT>
</TD></TR>
</TABLE>

</BODY>

</HTML>
