<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>SortedSeek.pm</title>
<link rel="stylesheet" href="../html/docs.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="block" valign="middle">
<big><strong><span class="block">&nbsp;SortedSeek.pm</span></strong></big>
</td></tr>
</table>


<!-- INDEX BEGIN -->
<div name="index">
<p><a name="__index__"></a></p>

<ul>

    <ul>

        <li><a href="#name">NAME</a></li>
        <li><a href="#synopsis">SYNOPSIS</a></li>
        <li><a href="#description">DESCRIPTION</a></li>
        <ul>

            <li><a href="#abstract">ABSTRACT</a></li>
            <li><a href="#the_two_basic_methods___numeric___and_alphabetic__">The two basic methods - <code>numeric()</code> and <code>alphabetic()</code></a></li>
            <li><a href="#return_values_with_search_success_and_failure">Return values with search success and failure</a></li>
            <li><a href="#adding_line_munging_to_make_the_basic_methods_more_useful">Adding line munging to make the basic methods more useful</a></li>
            <li><a href="#find_time__"><code>find_time()</code></a></li>
            <li><a href="#getting_lines_from_the_middle_of_a_file___get_between__">Getting lines from the middle of a file  - <code>get_between()</code></a></li>
            <li><a href="#getting_the_lines_from_the_beginning_of_a_file___get_between__">Getting the lines from the beginning of a file - <code>get_between()</code></a></li>
            <li><a href="#getting_lines_from_the_end_of_a_file___get_between__">Getting lines from the end of a file - <code>get_between()</code></a></li>
            <li><a href="#getting_lines_from_the_end_of_a_file___get_last__">Getting lines from the end of a file - <code>get_last()</code></a></li>
        </ul>

        <li><a href="#export">EXPORT</a></li>
        <li><a href="#options">OPTIONS</a></li>
        <ul>

            <li><a href="#file__sortedseek__error__">File::SortedSeek::error()</a></li>
            <li><a href="#file__sortedseek__was_exact__">File::SortedSeek::was_exact()</a></li>
            <li><a href="#file__sortedseek__set_cuddle___file__sortedseek__set_no_cuddle__">File::SortedSeek::set_cuddle()  File::SortedSeek::set_no_cuddle()</a></li>
            <li><a href="#file__sortedseek__set_descending___file__sortedseek__set_ascending__">File::SortedSeek::set_descending() File::SortedSeek::set_ascending()</a></li>
            <li><a href="#file__sortedseek__set_silent___file__sortedseek__set_verbose__">File::SortedSeek::set_silent()  File::SortedSeek::set_verbose()</a></li>
        </ul>

        <li><a href="#speed">SPEED</a></li>
        <li><a href="#bugs">BUGS</a></li>
        <li><a href="#credits">CREDITS</a></li>
        <li><a href="#author">AUTHOR</a></li>
        <li><a href="#see_also">SEE ALSO</a></li>
    </ul>

</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>
</p>
<h2><a name="name">NAME</a></h2>
<p>File::SortedSeek -  A Perl module providing fast access to large files</p>
<p>
</p>
<h2><a name="synopsis">SYNOPSIS</a></h2>
<pre>
  <span class="keyword">use</span> <span class="variable">File::SortedSeek</span> <span class="string">':all'</span><span class="operator">;</span>
  <span class="keyword">open</span> <span class="variable">BIG</span><span class="operator">,</span> <span class="variable">$file</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$!</span><span class="operator">;</span>
</pre>
<pre>
  <span class="comment"># find a number or the first number greater in a file (ascending order)</span>
  <span class="variable">$tell</span> <span class="operator">=</span> <span class="variable">numeric</span><span class="operator">(</span> <span class="variable">*BIG</span><span class="operator">,</span> <span class="variable">$number</span> <span class="operator">);</span>
  <span class="comment"># read a line in from where we matched in the file</span>
  <span class="variable">$line</span> <span class="operator">=</span> <span class="operator">&lt;</span><span class="variable">BIG</span><span class="operator">&gt;;</span>
  <span class="keyword">print</span> <span class="string">"Found exact match as $line"</span> <span class="keyword">if</span> <span class="variable">File::SortedSeek</span><span class="operator">:</span><span class="variable">was_exact</span><span class="operator">();</span>
</pre>
<pre>
  <span class="comment"># find a string or the first string greater in a file (alphabetical order)</span>
  <span class="variable">$tell</span> <span class="operator">=</span> <span class="variable">alphabetic</span><span class="operator">(</span> <span class="variable">*BIG</span><span class="operator">,</span> <span class="variable">$string</span> <span class="operator">);</span>
  <span class="variable">$line</span> <span class="operator">=</span> <span class="operator">&lt;</span><span class="variable">BIG</span><span class="operator">&gt;;</span>
</pre>
<pre>
  <span class="comment"># find a date in a logfile supplying a scalar localtime type string</span>
  <span class="variable">$tell</span> <span class="operator">=</span> <span class="variable">find_time</span><span class="operator">(</span> <span class="variable">*BIG</span><span class="operator">,</span> <span class="string">"Thu Aug 23 22:59:16 2001"</span> <span class="operator">);</span>
  <span class="comment"># or supplying GMT epoch time</span>
  <span class="variable">$tell</span> <span class="operator">=</span> <span class="variable">find_time</span><span class="operator">(</span> <span class="variable">*BIG</span><span class="operator">,</span> <span class="number">998571554</span> <span class="operator">);</span>
  <span class="comment"># get all the lines after our date</span>
  <span class="variable">@lines</span> <span class="operator">=</span> <span class="operator">&lt;</span><span class="variable">BIG</span><span class="operator">&gt;;</span>
</pre>
<pre>
  <span class="comment"># get the lines between two logfile dates</span>
  <span class="variable">$begin</span>  <span class="operator">=</span> <span class="variable">find_time</span><span class="operator">(</span> <span class="variable">*LOG</span><span class="operator">,</span> <span class="variable">$start</span> <span class="operator">);</span>
  <span class="variable">$end</span>    <span class="operator">=</span> <span class="variable">find_time</span><span class="operator">(</span> <span class="variable">*LOG</span><span class="operator">,</span> <span class="variable">$finish</span> <span class="operator">);</span>
  <span class="comment"># get lines as an array</span>
  <span class="variable">@lines</span> <span class="operator">=</span> <span class="variable">get_between</span><span class="operator">(</span> <span class="variable">*LOG</span><span class="operator">,</span> <span class="variable">$begin</span><span class="operator">,</span> <span class="variable">$end</span> <span class="operator">);</span>
  <span class="comment"># get lines as an array reference</span>
  <span class="variable">$lines</span> <span class="operator">=</span> <span class="variable">get_between</span><span class="operator">(</span> <span class="variable">*LOG</span><span class="operator">,</span> <span class="variable">$begin</span><span class="operator">,</span> <span class="variable">$end</span> <span class="operator">);</span>
</pre>
<pre>
  <span class="comment"># use you own sub to munge the file line data before comparison</span>
  <span class="variable">$tell</span> <span class="operator">=</span> <span class="variable">numeric</span><span class="operator">(</span> <span class="variable">*BIG</span><span class="operator">,</span> <span class="variable">$number</span><span class="operator">,</span> <span class="operator">\&amp;</span><span class="variable">epoch</span> <span class="operator">);</span>
  <span class="variable">$tell</span> <span class="operator">=</span> <span class="variable">alphabetic</span><span class="operator">(</span> <span class="variable">*BIG</span><span class="operator">,</span> <span class="variable">$string</span><span class="operator">,</span> <span class="operator">\&amp;</span><span class="variable">munge_line</span> <span class="operator">);</span>
</pre>
<pre>
  <span class="comment"># use methods on files in reverse alphabetic or descending numerical order</span>
  <span class="variable">File::SortedSeek::set_descending</span><span class="operator">();</span>
</pre>
<pre>
  <span class="comment"># for inexact matches set FH so first value read is before and second after</span>
  <span class="variable">File::SortedSeek::set_cuddle</span><span class="operator">();</span>
</pre>
<pre>
  # get last $n lines of any file as an array
  @lines = get_last( *BIG, $n )
  # or an array reference
  $lines = get_last( *BIG, $n )
  # change the input record separator from the OS default
  @lines = get_last( *BIG, $n, $rec_sep )</pre>
<p>
</p>
<h2><a name="description">DESCRIPTION</a></h2>
<p>File::SortedSeek provides fast access to data from large files. Three
methods <code>numeric()</code> <code>alphabetic()</code> and <code>find_time()</code> depend on the file data
being sorted in some way. Logfiles are a typical example of big files that
are sorted (by date stamp). The <code>get_between()</code> method can be used to get
a chunk of lines efficiently from anywhere in the file. The required postion(s)
for the <code>get_between()</code> method are supplied by the previous methods. The
<code>get_last()</code> method will efficiently get the last N lines of any file, sorted
or not.</p>
<p>With sorted data a linear search is not required. Here is a typical linear
search</p>
<pre>
    <span class="keyword">while</span> <span class="operator">(&lt;</span><span class="variable">FILE</span><span class="operator">&gt;)</span> <span class="operator">{</span>
        <span class="keyword">next</span> <span class="keyword">unless</span> <span class="regex">/$some_cond/</span>
        <span class="comment"># found cond, do stuff</span>
    <span class="operator">}</span>
</pre>
<p>Remember that old game where you try to guess a number between lets say 0
and say 128? Let's choose 101 and now try to guess it.</p>
<p>Using a linear search is the same as going 1 higher 2 higher 3 higher ...
100 higher 101 correct! Consider the geometric approach: 64 higher 96 higher
112 lower 104 lower 100 higher 102 lower - ta da must be 101! This is the
halving the difference search method and can be applied to any data set where
we can logically say higher or lower. In other words any sorted data set can
be searched like this. It is a far more efficient method - see the SPEED
section for a quick analysis.</p>
<p>
</p>
<h3><a name="abstract">ABSTRACT</a></h3>
<p>Fiel::SortedSeek provides fast access to data from large files. Three
methods <code>numeric()</code> <code>alphabetic()</code> and <code>find_time()</code> depend on the file data
being sorted in some way. Logfiles are a typical example of big files that
are sorted (by date stamp). The <code>get_between()</code> method can be used to get
a chunk of lines efficiently from anywhere in the file. The required postion(s)
for the <code>get_between()</code> method are supplied by the previous methods. The
<code>get_last()</code> method will efficiently get the last N lines of any file, sorted
or not.</p>
<p>
</p>
<h3><a name="the_two_basic_methods___numeric___and_alphabetic__">The two basic methods - <code>numeric()</code> and <code>alphabetic()</code></a></h3>
<p>There are two basic methods - <code>numeric()</code> to do numeric searches and
<code>alphabetic()</code> that does alphabetic searches.</p>
<p>You call the functions like this:</p>
<pre>
    <span class="variable">$tell</span> <span class="operator">=</span> <span class="variable">numeric</span><span class="operator">(</span> <span class="variable">*BIG</span><span class="operator">,</span> <span class="variable">$find</span> <span class="operator">);</span>
    <span class="variable">$tell</span> <span class="operator">=</span> <span class="variable">alphabetic</span><span class="operator">(</span> <span class="variable">*BIG</span><span class="operator">,</span> <span class="variable">$find</span> <span class="operator">);</span>
</pre>
<p>These methods take two required arguments. *BIG is a FILEHANDE to read from.
$find is the item you wish to find. $find must be appropriate to the function
as the numeric method will make numeric comparisons ( == &lt; &gt; ). Similarly the
alphabetic method makes string comparisons ( eq lt gt ). You will get strange
results if you use the wrong method just as you do if you say use &lt; when
you actually meant lt</p>
<p>
</p>
<h3><a name="return_values_with_search_success_and_failure">Return values with search success and failure</a></h3>
<p>The return value from the <code>numeric()</code> and <code>alphabetic()</code> methods depend on the
result of the search. If the search fails the return value is undefined.
A search can succeed in two ways. If an exact match is found then the
current file position pointer is set to the beginning of the matching line.
The return value is the corresponding response from <code>tell()</code>. This means that
the next read from &lt;FILEHANDLE&gt; will return the matching line.
Subsequent reads return the following lines as expected.</p>
<p>Alternatively a search will succeed if a point in the file can be found such
that $find is cuddled between two adjacent lines. For example consider
searching for the number 42 in a file like this:</p>
<pre>
    ..
    36
    40  &lt;- Before
    44  &lt;- After
    48
    ..</pre>
<p>The number 42 is not actually there but the search will still succeed as it
is between 40 and 44. By default the file postion pointer is set to the
beginning of the line '44' so the next read from &lt;FILEHANDLE&gt; will return
this line. If the File::SortedSeek::set_cuddle() function is called then the file
position pointer will be set to the beginning of line '40' so that the
first two reads from &lt;FILEHANDLE&gt; will cuddle the in-between value in $find.</p>
<p>
</p>
<h3><a name="adding_line_munging_to_make_the_basic_methods_more_useful">Adding line munging to make the basic methods more useful</a></h3>
<p>Both the numeric and alphabetic subs take an optional third argument.
This optional argument is a reference to a subroutine to munge the
file lines so that suitable values are extracted for comparison to $find.</p>
<pre>
    <span class="variable">$tell</span> <span class="operator">=</span> <span class="variable">numeric</span><span class="operator">(</span> <span class="variable">*BIG</span><span class="operator">,</span> <span class="variable">$find</span><span class="operator">,</span> <span class="operator">\&amp;</span><span class="variable">munge_line</span> <span class="operator">);</span>
    <span class="variable">$tell</span> <span class="operator">=</span> <span class="variable">alphabetic</span><span class="operator">(</span> <span class="variable">*BIG</span><span class="operator">,</span> <span class="variable">$find</span><span class="operator">,</span> <span class="operator">\&amp;</span><span class="variable">munge_line</span><span class="operator">,</span> <span class="variable">$dict_order</span><span class="operator">,</span> <span class="variable">$ignore_case</span> <span class="operator">);</span>
</pre>
<p>A good example of this is the <code>find_time()</code> function. This is just an
implementation of the basic numeric algorithm similar to this.</p>
<pre>
    <span class="variable">$tell</span> <span class="operator">=</span> <span class="variable">numeric</span> <span class="operator">(</span> <span class="variable">*BIG</span><span class="operator">,</span> <span class="variable">$epoch_seconds</span><span class="operator">,</span> <span class="operator">\&amp;</span><span class="variable">get_epoch_seconds</span> <span class="operator">);</span>
</pre>
<pre>
    <span class="keyword">sub</span><span class="variable"> get_epoch_seconds </span><span class="operator">{</span>
        <span class="keyword">use</span> <span class="variable">Time::Local</span><span class="operator">;</span>
        <span class="keyword">my</span> <span class="variable">$line</span>  <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
      <span class="keyword">return</span> <span class="keyword">undef</span> <span class="keyword">unless</span> <span class="keyword">defined</span> <span class="variable">$line</span><span class="operator">;</span>
        <span class="keyword">my</span> <span class="variable">%months</span> <span class="operator">=</span>
            <span class="operator">(</span> <span class="string">Jan</span> <span class="operator">=&gt;</span> <span class="number">0</span><span class="operator">,</span> <span class="string">Feb</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">,</span> <span class="string">Mar</span> <span class="operator">=&gt;</span> <span class="number">2</span><span class="operator">,</span> <span class="string">Apr</span> <span class="operator">=&gt;</span> <span class="number">3</span><span class="operator">,</span> <span class="string">May</span> <span class="operator">=&gt;</span> <span class="number">4</span><span class="operator">,</span>  <span class="string">Jun</span> <span class="operator">=&gt;</span> <span class="number">5</span><span class="operator">,</span>
              <span class="string">Jul</span> <span class="operator">=&gt;</span> <span class="number">6</span><span class="operator">,</span> <span class="string">Aug</span> <span class="operator">=&gt;</span> <span class="number">7</span><span class="operator">,</span> <span class="string">Sep</span> <span class="operator">=&gt;</span> <span class="number">8</span><span class="operator">,</span> <span class="string">Oct</span> <span class="operator">=&gt;</span> <span class="number">9</span><span class="operator">,</span> <span class="string">Nov</span> <span class="operator">=&gt;</span> <span class="number">10</span><span class="operator">,</span> <span class="string">Dec</span> <span class="operator">=&gt;</span> <span class="number">12</span><span class="operator">);</span>
        <span class="comment"># grab a scalar localtime looking like string from the line</span>
        <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$wday</span><span class="operator">,</span><span class="variable">$mon</span><span class="operator">,</span><span class="variable">$mday</span><span class="operator">,</span><span class="variable">$hours</span><span class="operator">,</span><span class="variable">$min</span><span class="operator">,</span><span class="variable">$sec</span><span class="operator">,</span><span class="variable">$year</span><span class="operator">)</span> <span class="operator">=</span>
            <span class="variable">$line</span> <span class="operator">=~</span> <span class="regex">m/(\w{3})\s+(\w{3})\s+(\d{1,2})\s+(\d\d):(\d\d):(\d\d)\s+(\d{4})/</span><span class="operator">;</span>
        <span class="keyword">unless</span> <span class="operator">(</span><span class="variable">$year</span><span class="operator">)</span> <span class="operator">{</span>
            <span class="variable">$error_msg</span> <span class="operator">=</span> <span class="string">"Unable to find time like string in line:\n$line"</span><span class="operator">;</span>
            <span class="keyword">warn</span> <span class="variable">$error_msg</span> <span class="keyword">unless</span> <span class="variable">$silent</span><span class="operator">;</span>
          <span class="keyword">return</span> <span class="keyword">undef</span><span class="operator">;</span>
        <span class="operator">}</span>
        <span class="variable">$mon</span> <span class="operator">=</span> <span class="variable">$months</span><span class="operator">{</span><span class="variable">$mon</span><span class="operator">}</span><span class="operator">;</span>   <span class="comment"># convert to numerical months 0 - 11</span>
      <span class="keyword">return</span> <span class="variable">timegm</span><span class="operator">(</span><span class="variable">$sec</span><span class="operator">,</span><span class="variable">$min</span><span class="operator">,</span><span class="variable">$hours</span><span class="operator">,</span><span class="variable">$mday</span><span class="operator">,</span><span class="variable">$mon</span><span class="operator">,</span><span class="variable">$year</span><span class="operator">);</span>
    <span class="operator">}</span>
</pre>
<p>As the search is made the test lines are passed to the munging sub. This sub
needs to return a string or number that we can perform comparison on. In this
case the sub looks for something that looks like a scalar <code>localtime()</code> string,
and assuming this is a date passes it to <code>timegm()</code> for conversion to
epoch seconds and returns this number.</p>
<p>The alphabetic function also takes optional 4th and 5th arguments.</p>
<p>If <em>$dict_order</em> is true, search by dictionary order (ignore anything but word
characters and whitespace).  The default is honour all characters.</p>
<p>If <em>$ignore_case</em> is true, ignore case.  The default is to honour case.</p>
<p>
</p>
<h3><a name="find_time__"><code>find_time()</code></a></h3>
<p>The <code>find_time()</code> function is an implementation of the basic numeric method as
discussed briefly above. You call it like:</p>
<pre>
    <span class="variable">$tell</span> <span class="operator">=</span> <span class="variable">find_time</span><span class="operator">(</span> <span class="variable">*LOG</span><span class="operator">,</span> <span class="string">'Thu Jan  1 00:42:00 1970'</span> <span class="operator">);</span>
    <span class="variable">$tell</span> <span class="operator">=</span> <span class="variable">find_time</span><span class="operator">(</span> <span class="variable">*LOG</span><span class="operator">,</span> <span class="variable">$epoch_seconds</span> <span class="operator">);</span>
</pre>
<p>You may use either a scalar <code>localtime()</code> like string or epoch seconds. If you
use epoch seconds it assumes gmtime. If in doubt use the string as although
it works internally with gmtime the offsets cancel out and the correct result
is returned.</p>
<p>
</p>
<h3><a name="getting_lines_from_the_middle_of_a_file___get_between__">Getting lines from the middle of a file  - <code>get_between()</code></a></h3>
<p>Say you have a logfile and you want to get the log between one date and
another. You can simply use two calls to the <code>find_time()</code> to get the beginning
and end positions and then use <code>get_between()</code> to get the lines.</p>
<pre>
    <span class="comment"># get the lines between two logfile dates</span>
    <span class="variable">$begin</span>  <span class="operator">=</span> <span class="variable">find_time</span><span class="operator">(</span> <span class="variable">*LOG</span><span class="operator">,</span> <span class="variable">$start</span> <span class="operator">);</span>
    <span class="variable">$end</span>    <span class="operator">=</span> <span class="variable">find_time</span><span class="operator">(</span> <span class="variable">*LOG</span><span class="operator">,</span> <span class="variable">$finish</span> <span class="operator">);</span>
    <span class="comment"># get lines as an array</span>
    <span class="variable">@lines</span> <span class="operator">=</span> <span class="variable">get_between</span><span class="operator">(</span> <span class="variable">*LOG</span><span class="operator">,</span> <span class="variable">$begin</span><span class="operator">,</span> <span class="variable">$end</span> <span class="operator">);</span>
    <span class="comment"># get lines as an array reference</span>
    <span class="variable">$lines</span> <span class="operator">=</span> <span class="variable">get_between</span><span class="operator">(</span> <span class="variable">*LOG</span><span class="operator">,</span> <span class="variable">$begin</span><span class="operator">,</span> <span class="variable">$end</span> <span class="operator">);</span>
</pre>
<p>The <code>get_between()</code> method returns an array in list context as above and a
reference to an array in scalar context.</p>
<p>This function needs to apply binmode so it splits the lines based on a system
specific default record separator. This is derived as below:</p>
<pre>
    <span class="keyword">my</span> <span class="variable">$default_rec_sep</span> <span class="operator">=</span> <span class="operator">(</span><span class="variable">$^O</span> <span class="operator">=~</span> <span class="regex">m/win32/i</span><span class="operator">)</span> <span class="operator">?</span> <span class="string">"\015\012"</span> <span class="operator">:</span>
                          <span class="operator">(</span> <span class="variable">$^O</span> <span class="operator">=~</span> <span class="regex">/mac/i</span> <span class="operator">)</span>  <span class="operator">?</span> <span class="string">"\015"</span>     <span class="operator">:</span> <span class="string">"\012"</span><span class="operator">;</span>
</pre>
<p>You can override this on a per file basis by passing the record separator
to the <code>get_between()</code> function.</p>
<pre>
    <span class="variable">@lines</span> <span class="operator">=</span> <span class="variable">get_between</span><span class="operator">(</span> <span class="variable">*LOG</span><span class="operator">,</span> <span class="variable">$begin</span><span class="operator">,</span> <span class="variable">$end</span><span class="operator">,</span> <span class="variable">$rec_sep</span> <span class="operator">);</span>
</pre>
<p>Modifying $/ has no effect. Note that *the record separator is not returned*
in the array. As a result the returned array has effectively had every
element chomped.</p>
<p>Warning - this method will apply binmode to the FH so line endings
will possibly not be converted properly if you try to continue to read from
it. As there is no <code>unbinmode()</code> close the FH afterwards and reopen it if you
want to read from it. You can seek FH, 0, $end if say you want to read more
lines after $end.</p>
<p>
</p>
<h3><a name="getting_the_lines_from_the_beginning_of_a_file___get_between__">Getting the lines from the beginning of a file - <code>get_between()</code></a></h3>
<p>Using the <code>get_between()</code> method you can efficiently get the lines at the
beginning of a file. Although you can just read in lines sequentially with
a while loop this requires that you test each line. If you can find the
end point using the <code>find_time()</code> <code>numeric()</code> or <code>alphabetic()</code> methods you
can the just get what you need. For large files many thousands of
unnecessary tests are avoided saving time. Using the example above
you simply set $begin to 0</p>
<pre>
    <span class="variable">$begin</span>  <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
    <span class="variable">$end</span>    <span class="operator">=</span> <span class="variable">find_time</span><span class="operator">(</span> <span class="variable">*LOG</span><span class="operator">,</span> <span class="variable">$finish</span> <span class="operator">);</span>
    <span class="variable">@lines</span>  <span class="operator">=</span> <span class="variable">get_between</span><span class="operator">(</span> <span class="variable">*LOG</span><span class="operator">,</span> <span class="variable">$begin</span><span class="operator">,</span> <span class="variable">$end</span> <span class="operator">);</span>
</pre>
<p>
</p>
<h3><a name="getting_lines_from_the_end_of_a_file___get_between__">Getting lines from the end of a file - <code>get_between()</code></a></h3>
<p>You can similarly use get between to get all the lines from a specific point
up to the end of the file. The end is just the size of the file so:</p>
<pre>
    <span class="variable">$begin</span> <span class="operator">=</span> <span class="variable">find_time</span><span class="operator">(</span> <span class="variable">*LOG</span><span class="operator">,</span> <span class="variable">$start</span> <span class="operator">);</span>
    <span class="variable">$end</span>   <span class="operator">=</span> <span class="keyword">-s</span> <span class="variable">LOG</span><span class="operator">;</span>
    <span class="variable">@lines</span> <span class="operator">=</span> <span class="variable">get_between</span><span class="operator">(</span> <span class="variable">*LOG</span><span class="operator">,</span> <span class="variable">$begin</span><span class="operator">,</span> <span class="variable">$end</span> <span class="operator">);</span>
</pre>
<p>
</p>
<h3><a name="getting_lines_from_the_end_of_a_file___get_last__">Getting lines from the end of a file - <code>get_last()</code></a></h3>
<p>This method does not depend on the file being sorted to work.
When you use the <code>get_last()</code> method the module estimates how many bytes at
the end of the file to read in. To make the estimate the module  multiplies
the default line length (80 chars) by the number of lines required and then
doubles it.</p>
<p>If it does not get sufficient lines on its first attempt it re-estimates
the line length from the actual data read in, re-calculates
the read, doubles it and then tries again. This algorithm is unlikely to
take more than 2 reads but if you have unusually long of short lines you may
get a small speed benefit by using the <code>set_line_length()</code> method to set the
average line length. The default is 80 chars per line. Setting the line length
close to the actual will also avoid reading a excessive quantity of data into
memory.</p>
<pre>
    # get last $n lines of any file as an array
    @lines = get_last( *BIG, $n )
    # or an array reference
    $lines = get_last( *BIG, $n )
    # change the input record separator from the default
    @lines = get_last( *BIG, $n, $rec_sep )</pre>
<p>This function needs to apply binmode so it splits the lines based on a system
specific default record separator. This is derived as below:</p>
<pre>
    <span class="keyword">my</span> <span class="variable">$default_rec_sep</span> <span class="operator">=</span> <span class="operator">(</span><span class="variable">$^O</span> <span class="operator">=~</span> <span class="regex">m/win32|vms/i</span><span class="operator">)</span> <span class="operator">?</span> <span class="string">"\015\012"</span> <span class="operator">:</span>
                          <span class="operator">(</span> <span class="variable">$^O</span> <span class="operator">=~</span> <span class="regex">/mac/i</span> <span class="operator">)</span> <span class="operator">?</span> <span class="string">"\015"</span> <span class="operator">:</span> <span class="string">"\012"</span><span class="operator">;</span>
</pre>
<p>You can override this on a per file basis by passing the record separator
$rec_sep to the <code>get_last()</code> function as shown. Modifying $/ has no effect.
Note that *the record separator is not returned* in the array. As a
result the returned array has effectively had every element chomped.</p>
<p>Warning - this method will apply binmode to the FH so line endings
will possibly not be converted properly if you try to continue to read from
it. As there is no <code>unbinmode()</code> close the FH afterwards and reopen it if you
want to read from it. You can seek FH, 0, $end if say you want to read more
lines after $end.</p>
<p>
</p>
<h2><a name="export">EXPORT</a></h2>
<p>Nothing is exported by default. The following 5 methods are available for
import:</p>
<pre>
    alphabetic()
    numeric()
    find_time()
    get_between()
    get_last()</pre>
<p>You can import just the method you want with a:</p>
<pre>
    <span class="keyword">use</span> <span class="variable">File::SortedSeek</span> <span class="string">'numeric'</span><span class="operator">;</span>
</pre>
<p>or all 5  methods using the ':all' tag.</p>
<pre>
    <span class="keyword">use</span> <span class="variable">File::SortedSeek</span> <span class="string">':all'</span><span class="operator">;</span>
</pre>
<p>
</p>
<h2><a name="options">OPTIONS</a></h2>
<p>There are some options available via non exported function
calls. You will need to fully specify the name if you want to use these.</p>
<p>
</p>
<h3><a name="file__sortedseek__error__">File::SortedSeek::error()</a></h3>
<p>If a function returns undefined there has been an error. <code>error()</code> will
contain the text of the last error message or a null string if there
was no error.</p>
<p>
</p>
<h3><a name="file__sortedseek__was_exact__">File::SortedSeek::was_exact()</a></h3>
<p><code>was_exact()</code> will return true if an exact match was found. It will be
false if the match was in between or failed.</p>
<p>
</p>
<h3><a name="file__sortedseek__set_cuddle___file__sortedseek__set_no_cuddle__">File::SortedSeek::set_cuddle()  File::SortedSeek::set_no_cuddle()</a></h3>
<p><code>set_cuddle()</code> changes the default line returned for in between matches  as
discussed above and <code>set_no_cuddle()</code> restores default behaviour</p>
<p>
</p>
<h3><a name="file__sortedseek__set_descending___file__sortedseek__set_ascending__">File::SortedSeek::set_descending() File::SortedSeek::set_ascending()</a></h3>
<p>By default ascending numerical order and alphabetical order are assumed.
This assumption can be reversed by calling <code>set_descending()</code> and reset
by calling <code>set_ascending()</code> We need to know the order to seek within the
file in the correct direction.</p>
<p>
</p>
<h3><a name="file__sortedseek__set_silent___file__sortedseek__set_verbose__">File::SortedSeek::set_silent()  File::SortedSeek::set_verbose()</a></h3>
<p>You can silence or activate error messages by calling these two subs. The
default is verbose.</p>
<p>
</p>
<h2><a name="speed">SPEED</a></h2>
<p>Here is a table that demonstrates the advantage of using the binary search
algorithm.</p>
<pre>
    Num items   Lin avg  Geom avg  Lin:Geom
            2         1         1         1
            4         2         2         1
            8         4         3         1
           16         8         4         2
           32        16         5         3
           64        32         6         5
          128        64         7         9
          256       128         8        16
          512       256         9        28
         1024       512        10        51
         2048      1024        11        93
         4096      2048        12       170
         8192      4096        13       315
        16384      8192        14       585
        32768     16384        15      1092
        65536     32768        16      2048
       131072     65536        17      3855
       262144    131072        18      7281
       524288    262144        19     13797
      1048576    524288        20     26214</pre>
<p>Even though there is an overhead involved with this search this is minor
as the number of tests required is so much less. Speed increases of 100-1000
of times are typical.</p>
<p>An OO interface slows things down by &gt; 50% so is not used.</p>
<p>
</p>
<h2><a name="bugs">BUGS</a></h2>
<p>The binmoding of the FH by <code>get_between()</code> and <code>get_last()</code> can not be
easily avoided.</p>
<p>
</p>
<h2><a name="credits">CREDITS</a></h2>
<p>Peter (Stig) Edwards for bugfixes and refactoring.</p>
<p>Search::Dict for the basis of the code used to replace the original core
search function.</p>
<p>
</p>
<h2><a name="author">AUTHOR</a></h2>
<p>(c) Dr James Freeman 2000-01 &lt;<a href="mailto:airmedical@gmail.com">airmedical@gmail.com</a>&gt;
All rights reserved.</p>
<p>This package is free software and is provided ``as is'' without express or
implied warranty. It may be used, redistributed and/or modified under the terms
of the Perl Artistic License (see <a href="http://www.perl.com/perl/misc/Artistic.html)">http://www.perl.com/perl/misc/Artistic.html)</a></p>
<p>
</p>
<h2><a name="see_also">SEE ALSO</a></h2>
<p>For details about the mystical significance of the number 42 and how it can
be applied to Life the Universe and everything see The Hitch Hiker's Guide
to the Galaxy 'trilogy' by the recently departed Douglas Adams.</p>
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="block" valign="middle">
<big><strong><span class="block">&nbsp;SortedSeek.pm</span></strong></big>
</td></tr>
</table>

</body>

</html>
